#!/usr/bin/env bash

function usage() {
    #TODO: More git-like usage
    #TODO: Support --force for publish
    echo "usage: git wize-flow <version|init|remove|feature|release|bugfix|hotfix> <start|publish|finish> <branch-name> [tag-version]"
}

function version() {
    #TODO: This should be replaced by the src/<stack>/version file contents
    echo "0.1.0"
}

function print_hints_banner() {

    echo "------------------------- WizeFlow -------------------------"
    echo
    if [[ "${__git_status-1}" == 0 || "${__wize_flow_status-1}" == 0 ]]; then
        case "${__stage-undefined}" in
            start)
                echo "Next step: Implement, add and commit your changes and continue with 'git wize-flow $__git_flow_type publish $__branch_name' when ready to submit PR"
                ;;
            publish)
                echo "Next step: Open PR using previous GitHub URL and wait for approval to merge"
                echo "           After merging, run 'git wize-flow $__git_flow_type finish $__branch_name' command to back merge (if applies) and clean-up"
                ;;
            finish)
                echo "Congratulations! Your branch $__branch_name was merged succesfully"
                ;;
            *)
                usage
                ;;
        esac
    else
        echo "Something went wrong with previous git command. Verify and try again"
    fi
        
    echo
    echo "------------------------- WizeFlow -------------------------"
            
}

function contains_element () {
    local e match="$1"
    shift
    for e; do [[ "$e" == "$match" ]] && return 0; done
    return 1
}

function validate_wize_flow {
    if [ "$(git config --get wizeflow.enabled)" != "yes" ]; then
        echo "wize-flow has not been initialized on this repository. Run 'git wize-flow init' first." >&2
        exit 1
    fi
}

function validate_inputs() {

    [[ "$#" -le 0 ]] && usage && exit 1

    __all_args=("$@")
    __git_override="false"
    __wize_flow_hints="false"

    if [[ "${__all_args[0]}" == "version" ]]; then
        version
        exit 0
    fi

    if [[ "${__all_args[0]}" == *"help"* || "${__all_args[0]}" == "-h" ]]; then
        usage
        exit 0
    fi

    #TODO: Support omitting directory argument
    if [[ "${__all_args[0]}" == "init" ]]; then
        [[ "$#" != "3" ]] && usage && exit 1
        "$(dirname "$0")"/wize-flow-setup.sh init "${__all_args[1]}" "${__all_args[2]}"
        exit $?
    fi
   
    validate_wize_flow

    if [[ "${__all_args[0]}" == "remove" ]]; then
        [[ "$#" != "2" ]] && usage && exit 1
        "$(dirname "$0")"/wize-flow-setup.sh remove "${__all_args[1]}"
        exit $?
    fi

    __wize_flow_hints="true"

    local will_override="false"
    contains_element "finish" "${__all_args[@]}" && will_override="true"

    local -r first_arg="${__all_args[0]}"
    local -r second_arg="${__all_args[1]-undefined}"
    local -r third_arg="${__all_args[2]-undefined}"
    local -r fourth_arg="${__all_args[3]-undefined}"
    
    # TODO: Consider case: 'git flow finish [tag]' and 'git flow release finish [tag]' when release or hotfix branch
    case "$first_arg" in
        feature|bugfix|release|hotfix)
            __git_flow_type="$first_arg"
            case "$second_arg" in
                start|publish|finish)
                    __stage="$second_arg"
                    ;;
                *)
                    usage
                    exit 1
                    ;; 
            esac 
            local branch_provided=false
            if [[ "$third_arg" != "undefined" ]]; then
                __branch_name="$third_arg"
                branch_provided=true
            else
                __branch_name=$(git rev-parse --abbrev-ref head | sed "s:$__git_flow_type/::")
            fi
            if [[ "$will_override" == "true" && ( "$__git_flow_type" == "release" || "$__git_flow_type" == "hotfix" ) ]]; then
                if [[ "$branch_provided" != "true" && "${#__all_args[@]}" == 2 ]]; then 
                    __tag_version="$second_arg"
                elif [[ "$branch_provided" == "true" && "${#__all_args[@]}" == 3 ]]; then
                    __tag_version="$third_arg"
                elif [[ "$branch_provided" == "true" && "${#__all_args[@]}" == 4 ]]; then
                    __tag_version="$fourth_arg"
                else
                    echo "tag-version is mandatory for $__git_flow_type branch" 1>&2
                    usage
                    exit 1
                fi
            fi
            ;;
        start|publish|finish)
            __git_flow_type=$(git rev-parse --abbrev-ref HEAD | grep -o '^[^\/]*')
            __stage="$first_arg"
            local branch_provided=false
            if [[ "$second_arg" != "undefined" ]]; then
                __branch_name="$second_arg"
                branch_provided=true
            else
                __branch_name=$(git rev-parse --abbrev-ref head | sed "s:$__git_flow_type/::")
            fi
            if [[ "$will_override" == "true" && ( "$__git_flow_type" == "release" || "$__git_flow_type" == "hotfix" ) ]]; then
                if [[ "$branch_provided" != "true" && "${#__all_args[@]}" == 2 ]]; then                
                    __tag_version="$second_arg"
                elif [[ "$branch_provided" == "true" && "${#__all_args[@]}" == 3 ]]; then
                    __tag_version="$third_arg"
                elif [[ "$branch_provided" == "true" && "${#__all_args[@]}" == 4 ]]; then
                    __tag_version="$fourth_arg"
                else
                    echo "tag-version is mandatory for $__git_flow_type branch" 1>&2
                    usage
                    exit 1
                fi
            fi
            ;;
        *)
            usage
            exit 1
            ;;
    esac

    case "$__git_flow_type" in
        feature|bugfix|release|hotfix)
            ;;
        *)
            echo "ERROR: $__git_flow_type should be feature|bugfix|release|hotfix" 1>&2
            usage
            exit 1
            ;;
    esac

    # If no argument is finish, return and run normal git
    [[ "$__stage" != "finish" ]] && return

    __git_override="true" 
    __all_args=("$__git_flow_type" "$__branch_name")
    if [[ "$__git_flow_type" == "release" || "$__git_flow_type" == "hotfix" ]]; then
         __all_args=("${__all_args[@]}" "$__tag_version")
    fi

}

function run_git_flow() {

    # We run 'git' if we are not running our wize-flow script later
    if [[ "$__git_override" == "false" ]]; then
        # Hacky way to avoid an unbound error for an empty array.
        # See: https://stackoverflow.com/questions/7577052/bash-empty-array-expansion-with-set-u
        git flow ${__all_args[@]+"${__all_args[@]}"}
        __git_status=$?
    fi
   
}

function run_wize_flow() {

    if [[ "$__wize_flow_hints" == "true" ]]; then

        if [[ "$__git_override" == "true" ]]; then
            # Hacky way to avoid an unbound error for an empty array.
            # See: https://stackoverflow.com/questions/7577052/bash-empty-array-expansion-with-set-u
            "$(dirname "$0")"/git-flow-finish.sh ${__all_args[@]+"${__all_args[@]}"}
            __wize_flow_status=$?
        fi
        
        print_hints_banner
    fi
       
} 

main() {
    ####### GIT FUNCTION START #######

    # We do not want the script to exit on failed scripts
    set +o errexit
    # We do not want to exit on error inside any functions or subshells.
    set +o errtrace
    # Do not allow use of undefined vars. Use ${VAR:-} to use an undefined VAR
    set -o nounset
    # Catch the error in case mysqldump fails (but gzip succeeds) in `mysqldump |gzip`
    set -o pipefail

    validate_inputs "$@"
    run_git_flow
    run_wize_flow
    if [[ "${__git_status-undefined}" != "undefined" ]]; then
        exit "$__git_status"
    else 
        exit "$__wize_flow_status"
    fi

    ####### GIT FUNCTION END #######
}

main "$@"
